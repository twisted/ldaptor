#!/usr/bin/python

from __future__ import print_function
import sys
from twisted.internet import reactor
from ldaptor.protocols.ldap import ldapconnector, ldapsyntax, ldapclient
from ldaptor.protocols import pureber, pureldap
from ldaptor import usage, ldapfilter, config 

def _printIPAddressVOne(name, ipAddress):
    print('A'+name+'.%|86400|'+ipAddress)

def _printPTRVOne(name, ipAddress):
    octets = ipAddress.split('.')
    octets.reverse()
    octets.append('in-addr.arpa.')
    print('P'+('.'.join(octets))+'|86400|'+name+'.%')

def _printHostLineVTwo(name, ttl, recordType, ipAddress):
    nameStr = name+'.'
    if '.' not in name: nameStr = name+'.%'
    # If the 'ip' is an IP address (i.e. removing the '.' leaves a numeric string) then no further treatment is necessary.
    # If it's a name (i.e. second charaters is in the alphanet) then it needs a trailing .
    # If it's a name that needs a domain then append the %
    ipStr = ipAddress
    if not ((ipAddress.replace('.', '')).replace(' ', '')).isdigit():
        ipStr = ipAddress+'.'
        if '.' not in ipAddress: ipStr = ipAddress+'.%'
    print(nameStr+'\t'+ttl+'\t'+recordType+'\t'+ipStr+' ~')

def _printPTRVTwo(name, ttl, ipAddress):
    octets = ipAddress.split('.')
    octets.reverse()
    octets.append('in-addr.arpa.')
    nameStr = name+'.'
    if '.' not in name: nameStr = name+'.%'
    print (('.'.join(octets))+'\t'+ttl+'\tPTR\t'+nameStr+' ~')

exitStatus = 0

def error(fail):
    print('fail:', str(fail), file=sys.stderr) #.getErrorMessage()
    global exitStatus
    exitStatus = 1

def only(serverResponse, attrName):
    assert len(serverResponse[attrName]) == 1, \
           "object %s attribute %r has multiple values: %s" \
           % (serverResponse.dn, attrName, serverResponse[attrName])
    for val in serverResponse[attrName]:
        return val

def getHosts(serverRequest, filterText):
    filt = pureldap.LDAPFilter_equalityMatch(
        attributeDesc=pureldap.LDAPAttributeDescription('objectClass'),
        assertionValue=pureber.BEROctetString('maradnsRecord'))
    if filterText:
        filt = pureldap.LDAPFilter_and(value=(filterText, filt))

    def _cbGotHost(serverResponse):
        name = str(only(serverResponse, 'idnsName'))

        # If there's a TTL in the response the use it, otherwise, give it the default.
        # The /ttl line in the MaraDNS zone file is not implemented here.
        ttl = '86400'
        if 'dNSTTL' in serverResponse.keys(): ttl = str(only(serverResponse, 'dNSTTL'))

        # Array to translate the record types from LDAP language to MaraDNS language
        # So the MX record is a hack but that's how BIND does it too
        records = [
            ['FQDNRecord', 'FQDN4'],
            ['aRecord', 'A'],
            ['cNAMERecord', 'CNAME'],
            ['sRVRecord', 'SRV'],
            ['nSRecord', 'NS'],
            ['tXTRecord', 'TXT'],
            ['mXRecord', 'MX'],
            ['pTRRecord', 'PTR']]

        for record in records:
            if record[0] in serverResponse.keys():
                for ipAddress in serverResponse[record[0]]:
                    if maraDnsVersion == 1 and record[0] == 'aRecord': _printIPAddressVOne(name, ipAddress) ; _printPTRVOne(name, ipAddress)
                    if maraDnsVersion == 2: 
                        if record[0] == 'pTRRecord':
                            _printPTRVTwo(name, '+'+ttl, ipAddress)
                        else:
                            _printHostLineVTwo(name, '+'+ttl, record[1], ipAddress)

    serverResponse = serverRequest.search(filterObject=filt,
                                          attributes=[
                                              'idnsName', 'FQDNRecord',
                                              'aRecord', 'cNAMERecord',
                                              'dNSTTL', 'mXRecord',
                                              'sRVRecord', 'nSRecord',
                                              'pTRRecord','tXTRecord'],
                                          callback=_cbGotHost)
    return serverResponse 

def cbConnected(client, filterText):
    serverRequest = ldapsyntax.LDAPEntryWithClient(client, cfg.getBaseDN())
    d = getHosts(serverRequest, filterText)
    def unbind(r, serverRequest):
        serverRequest.client.unbind()
        return r
    d.addCallback(unbind, serverRequest)
    return d

def main(filterText):
    from twisted.python import log
    log.startLogging(sys.stderr, setStdout=0)

    try:
        baseDN = cfg.getBaseDN()
    except config.MissingBaseDNError as e:
        print("%s: %s." % (sys.argv[0], e), file=sys.stderr)
        sys.exit(1)

    if filterText is not None:
        filt = ldapfilter.parseFilter(filterText)
    else:
        filt = None

    c = ldapconnector.LDAPClientCreator(reactor, ldapclient.LDAPClient)
    d = c.connectAnonymously(
        baseDN,
        overrides=cfg.getServiceLocationOverrides())
    d.addCallback(cbConnected, filt)
    d.addErrback(error)
    d.addBoth(lambda x: reactor.stop())

    reactor.run()
    sys.exit(exitStatus)

class MyOptions(usage.Options, usage.Options_service_location, usage.Options_base_optional):
    """LDAPtor maradns v1 and v2 zone file exporter"""
    def parseArgs(self, customFilter=None):
        self.opts['customFilter'] = customFilter

if __name__ == "__main__":
    try:
        opts = MyOptions()
        opts.parseOptions()
    except usage.UsageError as usageError:
        sys.stderr.write('%s: %s\n' % (sys.argv[0], usageError))
        sys.exit(1)

    cfg = config.LDAPConfig(baseDN=opts['base'],
                            serviceLocationOverrides=opts['service-location'])
    maraDnsVersion = config.maraDnsVersion()
    main(opts['customFilter'])
